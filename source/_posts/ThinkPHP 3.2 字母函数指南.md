---
title: ThinkPHP 3.2 字母函数指南
date: 2021-11-13 21:12:29
tags: [PHP, ThinkPHP]
categories: PHP
description: ThinkPHP 3.2 字母函数指南
---

# A 方法

用于在内部实例化控制器，调用格式：

```php
// A('[项目://][分组/]模块','控制器层名称')
$User = A('User');
$User = A('Admin://User');
```

实例化控制器后，就可以调用该控制器中的方法，不过需要注意的情况是，在跨项目调用的情况下，如果你的操作方法 有针对当前控制器的特殊变量操作，会有一些未知的问题，所以，一般来说，官方建议需要公共调用的控制器层单独开发，不要有太多的依赖关系。

# B 方法

这是随着行为应运而生的新生函数，可以执行某个行为，例如

```php
B('app_begin');
```

就是在项目开始之前，执行这个行为定义的所有函数。支持 2 个参数，第二个参数支持需要接受一个数组，例如

```php
B('app_begin', ["name" => "tdweb","time"=>time()]);
```

# C 方法

C 方法是 Think 用于设置、获取，以及保存配置参数的方法，使用频率较高。

动态设置配置参数，配置参数不区分大小写，但是建议保持统一大写的配置定义规范。

```php
C('DB_NAME','think');
```

支持二级配置参数的设置，配置参数不建议超过二级。例如：

```php
C('USER.USER_ID',8);
```

如果要设置多个参数，可以使用批量设置，例如：

```php
$config['user_id'] = 1;
$config['user_type'] = 1;
C($config);
```

如果传入的配置参数为空，表示获取全部的参数：

```php
$config = C();
```

# D 方法

D 方法应该是用的比较多的方法了，用于实例化自定义模型类，是 Think 框架对 Model 类实例化的一种封装，并实现了单例模式，支持跨项目和分组调用，调用格式如下：

```php
D('[项目://][分组/]模型','模型层名称')
```

方法的返回值是实例化的模型对象。

D 方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化 Model 基类，同时对于已实例化过的模型，不会重复去实例化。

D 方法最常用的用法就是实例化当前项目的某个自定义模型，例如：

```php
// 实例化 User 模型
$User = D('User');
```

# F 方法

F 方法其实是 S 方法的一个子集功能，仅用于简单数据缓存，并且只能支持文件形式，不支持缓存有效期，因为采用的是返回方式，所以其效率较 S 方法较高，因此我们也称之为快速缓存方法。

F 方法的特点是：

- 简单数据缓存；
- 文件形式保存；
- 采用返回数据方式加载缓存；
- 支持子目录缓存以及自动创建；
- 支持删除缓存和批量删除；

写入和读取缓存

```php
F('data','test data');
```

默认的保存起始路径是 *DATA_PATH*（该常量在默认配置位于 *RUNTIME_PATH.'Data/'* 下面），也就是说会生成文件名为 *DATA_PATH.'data.'* 的缓存文件。

注意：确保你的缓存标识的唯一，避免数据覆盖和冲突。

下次读取缓存数据的时候，使用：

```php
$Data = F('data');
```

我们可以采用子目录方式保存，例如：

```php
F('user/data',$data); // 缓存写入
F('user/data'); // 读取缓存
```

就会生成 *DATA_PATH.'user/data.'* 缓存文件，如果 user 子目录不存在的话，则会自动创建，也可以支持多级子目录，例如：

```php
F('level1/level2/data',$data);
```

如果需要指定缓存的起始目录，可以用下面的方式：

```php
F('data',$data,TEMP_PATH);
```

删除缓存

```php
F('data',NULL);
```

# G 方法

G 方法的作用包括标记位置和区间统计两个功能，下面来看下具体用法：

## 标记位置

G 方法的第一个用法就是标记位置，例如：

```php
G('begin');
```

表示把当前位置标记为 begin 标签，并且记录当前位置的执行时间，如果环境支持的话，还能记录内存占用情况。可以在任何位置调用 G 方法标记。

## 运行时间统计

标记位置后，我们就可以再次调用 G 方法进行区间统计了，例如：

```php
G('begin');
// ...其他代码段
G('end');
// ...也许这里还有其他代码
// 进行统计区间
echo G('begin','end').'s';
```

*G('begin','end')* 表示统计 begin 位置到 end 位置的执行时间（单位是秒），begin 必须是一个已经标记过的位置，如果这个时候 end 位置还没被标记过，则会自动把当前位置标记为 end 标签，输出的结果类似于：

```php
0.0056s
```

默认的统计精度是小数点后 4 位，如果觉得这个统计精度不够，还可以设置例如：

```php
G('begin','end',6).'s';
```

内存开销统计

如果你的环境支持内存占用统计的话，还可以使用 G 方法进行区间内存开销统计（单位为 kb），例如：

```php
echo G('begin','end','m').'kb';
```

第三个参数使用 m 表示进行内存开销统计，输出的结果可能是：

```php
625kb
```

# I 方法

正如你所见到的一样，I 方法是 Thinkphp 众多单字母函数中的新成员，其命名来自于英文 Input（输入），主要用于更加方便和安全的获取系统输入变量，可以用于任何地方，用法格式如下：

```php
I('变量类型.变量名',['默认值'],['过滤方法'])
```

变量类型是指请求方式或者输入类型，包括：

|方式|说明|
|:--:|:--:|
|get| 获取 GET 参数|
|post|	获取 POST 参数|
|param |	自动判断请求类型获取 GET、POST 或者 PUT 参数|
|request|	获取 REQUEST 参数|
|put	|获取 PUT 参数|
|session	|获取 $_SESSION 参数|
|cookie	|获取 $_COOKIE 参数|
|server	|获取 $_SERVER 参数|
|globals	|获取 $GLOBALS 参数|

注意：变量类型不区分大小写。变量名则严格区分大小写。

默认值和过滤方法均属于可选参数。

# L 方法

L 方法用于启用多语言的情况下，设置和获取当前的语言定义。

调用格式：

```php
L('语言变量',['语言值'])
```

# M 方法

M 方法用于实例化一个基础模型类，和 D 方法的区别在于：

- 不需要自定义模型类，减少 IO 加载，性能较好；
- 实例化后只能调用基础模型类（默认是 Model 类）中的方法；
- 可以在实例化的时候指定表前缀、数据库和数据库的连接信息；

D 方法的强大则体现在你封装的自定义模型类有多强，不过随着新版 Think 框架的基础模型类的功能越来越强大，M 方法也比 D 方法越来越实用了。

M 方法的调用格式：

```php
M('[基础模型名:]模型名','数据表前缀','数据库连接信息')
```

# R 方法

R 方法用于调用某个控制器的操作方法，是 A 方法的进一步增强和补充。

R 方法的调用格式：

```php
R('[项目://][分组/]模块/操作','参数','控制器层名称')
```

可以通过 R 方法在其他控制器里面调用这个操作方法（一般 R 方法用于跨模块调用）

```php
$data = R('User/detail',array('5'));
```

官方的建议是不要在同一层多太多调用，会引起逻辑的混乱，被公共调用的部分应该封装成单独的接口，可以借助3.1的新特性多层控制器，单独添加一个控制器层用于接口调用

# S 方法

S 方法还支持对当前的缓存方式传入缓存参数，例如：

```php
S('data',$Data,3600,'File',array('length'=>10,'temp'=>RUNTIME_PATH.'temp/'));
```

# T 方法

为了更方便的输出模板文件，新版封装了一个 T 函数用于生成模板文件名。

```php
T([资源://][模块@][主题/][控制器/]操作,[视图分层])
```

T 函数的返回值是一个完整的模板文件名，可以直接用于 display 和 fetch 方法进行渲染输出。

# U 方法

U 方法用于完成对 URL 地址的组装，特点在于可以自动根据当前的 URL 模式和设置生成对应的 URL 地址，格式为：

```php
U('地址','参数','伪静态','是否跳转','显示域名');
```

在模板中使用 U 方法而不是固定写死 URL 地址的好处在于，一旦你的环境变化或者参数设置改变，你不需要更改模板中的任何代码。